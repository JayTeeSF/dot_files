# return if "universal-darwin10.0" == RUBY_PLATFORM

require 'rubygems'

MACRUBY = false
if ! MACRUBY # macruby has trouble w/ this
  require 'irb/completion'
  module IRB  # now you can type: IRB.quiet or IRB.verbose from within irb
    def self.output_value
      ap @context.last_value
    end

    def self.result_format 
      conf[:PROMPT][conf[:PROMPT_MODE]][:RETURN] 
    end 
    def self.result_format=(str) 
      result_format.replace(str) 
    end 
    def self.verbose 
      self.result_format = "=> %s\n" 
    end 
    def self.quiet 
      self.result_format = '' 
    end 
  end 

  # Load your rails specific stuff (.railsrc)
  script_console_running = ENV.include?('RAILS_ENV') && IRB.conf[:LOAD_MODULES] && IRB.conf[:LOAD_MODULES].include?('console_with_helpers')
  rails_running = ENV.include?('RAILS_ENV') && !(IRB.conf[:LOAD_MODULES] && IRB.conf[:LOAD_MODULES].include?('console_with_helpers'))
  irb_standalone_running = !script_console_running && !rails_running
end

unless self.class.const_defined? "IRB_RC_HAS_LOADED"

  begin # ANSI codes
    ANSI_BLACK    = "\033[0;30m"
    ANSI_GRAY     = "\033[1;30m"
    ANSI_LGRAY    = "\033[0;37m"
    ANSI_WHITE    =  "\033[1;37m"
    ANSI_RED      ="\033[0;31m"
    ANSI_LRED     = "\033[1;31m"
    ANSI_GREEN    = "\033[0;32m"
    ANSI_LGREEN   = "\033[1;32m"
    ANSI_BROWN    = "\033[0;33m"
    ANSI_YELLOW   = "\033[1;33m"
    ANSI_BLUE     = "\033[0;34m"
    ANSI_LBLUE    = "\033[1;34m"
    ANSI_PURPLE   = "\033[0;35m"
    ANSI_LPURPLE  = "\033[1;35m"
    ANSI_CYAN     = "\033[0;36m"
    ANSI_LCYAN    = "\033[1;36m"

    ANSI_BACKBLACK  = "\033[40m"
    ANSI_BACKRED    = "\033[41m"
    ANSI_BACKGREEN  = "\033[42m"
    ANSI_BACKYELLOW = "\033[43m"
    ANSI_BACKBLUE   = "\033[44m"
    ANSI_BACKPURPLE = "\033[45m"
    ANSI_BACKCYAN   = "\033[46m"
    ANSI_BACKGRAY   = "\033[47m"

    ANSI_RESET      = "\033[0m"
    ANSI_BOLD       = "\033[1m"
    ANSI_UNDERSCORE = "\033[4m"
    ANSI_BLINK      = "\033[5m"
    ANSI_REVERSE    = "\033[7m"
    ANSI_CONCEALED  = "\033[8m"

    XTERM_SET_TITLE   = "\033]2;"
    XTERM_END         = "\007"
    ITERM_SET_TAB     = "\033]1;"
    ITERM_END         = "\007"
    SCREEN_SET_STATUS = "\033]0;"
    SCREEN_END        = "\007"
  end

  #HISTFILE = "~/.irb_history"
  #  begin # Read command history
  #    if defined? Readline::HISTORY
  #      histfile = File::expand_path( HISTFILE )
  #      if File::exists?( histfile )
  #        lines = IO::readlines( histfile ).collect {|line| line.chomp}
  #        puts "Read %d saved history commands from %s." %
  #          [ lines.nitems, histfile ] if $DEBUG || $VERBOSE
  #        Readline::HISTORY.push( *lines )
  #      else
  #        puts "History file '%s' was empty or non-existant." %
  #          histfile if $DEBUG || $VERBOSE
  #      end
  #    end
  #  end
  #
  #  begin # Ben Bleything's history methods, as seen at http://dotfiles.org/~topfunky/.irbrc
  #    def history(how_many = 50)
  #      history_size = Readline::HISTORY.size
  #
  #      # no lines, get out of here
  #      puts "No history" and return if history_size == 0
  #
  #      start_index = 0
  #
  #      # not enough lines, only show what we have
  #      if history_size <= how_many
  #        how_many  = history_size - 1
  #        end_index = how_many
  #      else
  #        end_index = history_size - 1 # -1 to adjust for array offset
  #        start_index = end_index - how_many 
  #      end
  #
  #      start_index.upto(end_index) {|i| print_line i}
  #      nil
  #    end
  #    alias :h  :history
  #
  #    # -2 because -1 is ourself
  #    def history_do(lines = (Readline::HISTORY.size - 2))
  #      irb_eval lines
  #      nil
  #    end 
  #    alias :h! :history_do
  #
  #    # apparently my IRB saves it's own history!
  #    # def history_write(filename, lines)
  #    #   file = File.open(filename, 'w')
  #    # 
  #    #   get_lines(lines).each do |l|
  #    #     file << "#{l}\n"
  #    #   end
  #    # 
  #    #   file.close
  #    # end
  #    # alias :hw :history_write
  #
  #    def get_line(line_number)
  #      Readline::HISTORY[line_number]
  #    end
  #
  #    def get_lines(lines = [])
  #      return [get_line(lines)] if lines.is_a? Fixnum
  #
  #      out = []
  #
  #      lines = lines.to_a if lines.is_a? Range
  #
  #      lines.each do |l|
  #        out << Readline::HISTORY[l]
  #      end
  #
  #      return out
  #    end
  #
  #    def print_line(line_number, show_line_numbers = true)
  #      print "[%04d] " % line_number if show_line_numbers
  #      puts get_line(line_number)
  #    end
  #
  #    def irb_eval(lines)
  #      to_eval = get_lines(lines)
  #
  #      eval to_eval.join("\n")
  #
  #      to_eval.each {|l| Readline::HISTORY << l}
  #    end
  #  end

  # e = FooClass.new
  # pm(e, :minus_all => true)
  # pm(e, :minus_klass => [ActiveRecord::Base])
  # pm(e, :minus => true)
  # pm(e, :instance_methods => true)
  begin # Utility methods
    def pm(obj, options={}) # Print methods
      methods = obj.methods
      methods = obj.respond_to(:meta_class) ?  obj.meta_class.instance_methods(false) : obj.class.instance_methods(false) if options[:instance_methods]

      # puts "options: #{options.inspect}"

      # puts "(0) method_count: #{methods.count}"

      methods -= Object.methods unless options[:more]

      # puts "(1) method_count: #{methods.count}"
      parent_objects = obj.class.ancestors
      if defined?(ActiveRecord::Base) && parent_objects.include?(ActiveRecord::Base)
        ar_base_idx = parent_objects.rindex(ActiveRecord::Base) || 1
      end
      # puts "ar_base_idx: #{ar_base_idx}; p_o.size: #{parent_objects.size}"

      if parent_objects.size > 1
        parent_objects[1 .. ar_base_idx].collect{|klass| methods -= klass.methods} if options[:minus]
        parent_objects[1 .. (parent_objects.size - 1)].collect{|klass| methods -= klass.methods} if options[:minus_all]
        # puts "(1b) method_count: #{methods.count}"

        if options[:minus_klass] && options[:minus_klass].kind_of?(Array)
          options[:minus_klass].collect do |klass|
            methods -= parent_objects[parent_objects.rindex(klass)].methods if parent_objects.include?(klass)
          end
        end
      end
      # puts "(2a) method_count: #{methods.count}"

      filter = options[:filter] if options[:filter].kind_of?(Regexp)
      methods = methods.select {|name| name =~ filter} if filter
      # puts "(2b) method_count: #{methods.count}"

      data = methods.sort.collect do |name|
        method = obj.method(name)
        if method.arity == 0
          args = "()"
        elsif method.arity > 0
          n = method.arity
          args = "(#{(1..n).collect {|i| "arg#{i}"}.join(", ")})"
        elsif method.arity < 0
          n = -method.arity
          args = "(#{(1..n).collect {|i| "arg#{i}"}.join(", ")}, ...)"
        end
        klass = $1 if method.inspect =~ /Method: (.*?)#/
        [name, args, klass]
      end
      max_name = data.collect {|item| item[0].size}.max
      max_args = data.collect {|item| item[1].size}.max
      data.each do |item| 
        print " #{ANSI_BOLD}#{item[0].rjust(max_name)}#{ANSI_RESET}"
        print "#{ANSI_GRAY}#{item[1].ljust(max_args)}#{ANSI_RESET}"
        print "   #{ANSI_LGRAY}#{item[2]}#{ANSI_RESET}\n"
      end
      data.size
    end
  end
  IRB_RC_HAS_LOADED = true
end

if ENV['RAILS_ENV']
  load File.dirname(__FILE__) + '/.railsrc'
end

# extras:
require 'ap'
if ! MACRUBY
  require 'wirble'
  Wirble.init
  Wirble.colorize
end

#load File.dirname(__FILE__) + '/.irb_lib/*.rb'
Dir[File.dirname(__FILE__) + "/.irb_lib/*.rb"].each { |file| require(file)}
include ProfileGrapher
